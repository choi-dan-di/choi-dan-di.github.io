---
title: "[C++] 포인터 기초"
excerpt: "포인터의 개념에 대해 알아보기"

categories:
  - C/C++
tags:
  - [C/C++, C++, Visual Studio, pointer, basic, pointer basic]

permalink: /cpp/pointer-basic/

toc: true
toc_sticky: true

date: 2022-11-17 23:23:12+0900
last_modified_at: 2022-11-17 23:23:16+0900
---

## 👻 포인터
**포인터(Pointer)**는 우리가 데이터 자체에 접근하기 위해 주소값을 가리키는 개념을 의미한다. 일반적인 변수 선언 방식은 해당 변수에 값 자체를 담으라는 의미이지만, 포인터를 사용하면 **메모리의 주소를 담으라는 의미**이다.

```c++
int* ptr = &number;
```

사용방법은 위처럼 타입 뒤에 **별(*)**을 붙이고 주소를 담을 변수 앞에 **앰퍼센트(&)**를 붙인다.

포인터는 개발 환경에 따라 **4바이트(32비트)** 혹은 **8바이트(64비트)**의 고정 크기를 가진다.

> 포인터는 포탈과 같다. 사용하는 순간 해당 주소값으로 넘어간다고 생각하면 된다.

***

### 🌱 포인터를 사용하는 이유
우리가 이전에 배웠던 내용을 토대로 보면, 일반적으로 변수 선언은 다음과 같이 하게된다.

```c++
int number = 1;
```

해당 방식은 number라는 변수에 1이라는 값을 담으라는 의미이다.

함수 내에 선언하면 스택 메모리에 저장되는데 해당 방법을 사용하게 되면 값을 가져오고 사용하는 것엔 아무런 문제가 없다. 어셈블리어보다 훨씬 간단하고 편리하지만, 단점은 **원본을 수정하기가 어렵다.** 이러한 단점을 보완하기위해 나온 개념이 바로 **포인터**이다.

***

### 🌱 포인터 확인해보기
디버깅을 실행해보자. 코드는 다음과 같다.

```c++
int main()
{
    int number = 1;

    int* ptr = &number;
}
```

- **조사식**   
![Alt Text](/assets/images/posts_img/basics/cpp/pointer/pointer-basic/debug.PNG)   

조사식으로 ``` number ```와 ``` ptr ```의 주소값을 확인한 후 메모리 창에 실행시켜보자.

- **메모리**   
![Alt Text](/assets/images/posts_img/basics/cpp/pointer/pointer-basic/memory.PNG)   

``` number ```에 해당하는 메모리의 값은 **1**이 들어가 있고 포인터인 ``` ptr ```에 해당하는 메모리의 값은 ``` number ```의 주소값이 들어가 있는 것을 알 수 있다.

> 메모리 창에 ``` &변수이름 ```으로도 주소를 찾을 수 있다.

***

## 👻 추가 문법
위에서 알아봤던 문법은 포인터 변수를 생성해 해당 변수에 메모리의 주소값을 넣어라는 의미였다. 이제는 그 주소로 가서 값을 가져온 다음 작업을 하라는 의미의 문법을 알아보자.

```c++
// *변수이름 = 값;
int value1 = *ptr;
*ptr = 2;
```

변수 이름 앞에 **별(*)**을 붙이게되면 ``` ptr ```이 가리키는 주소의 값을 가져와 ``` value1 ```에 담으라는 의미이다. ``` *ptr = 2; ```를 실행하면 원본인 ``` number ```의 값이 바뀌게 되는 것을 확인할 수 있다.

![Alt Text](/assets/images/posts_img/basics/cpp/pointer/pointer-basic/asm.PNG)   

어셈블리어로 확인해보면 두 번 이동(``` 포인터 👉 포인터의 주소 ```)하는 것을 알 수 있다.

***

## 👻 포인터에 타입은 왜 붙일까?
포인터는 크기도 고정되어있고 메모리 주소값만 저장해서 자칫 타입이 필요없어보일 수도 있지만 **포인터의 추가 정보**를 알려준다. 결혼식 청첩장에 있는 주소는 예식장 주소이고 명함에 있는 주소는 회사의 주소인 것처럼 말이다.

즉, 해당 포인터가 가리키는 **데이터가 어떤 값인지 알려줘서 분석할 때 참고**하라고 타입을 설정해주는 것이다.

> 대략적인 이유는 위와 같지만 타입을 지정했다고 꼭 그 타입으로 분석이 된다는 보장은 없다.

***

### 🌱 타입의 불일치
아래처럼 코드를 작성하고 디버깅을 진행해보자.

```c++
// __int64* ptr2 = &number;     // 에러남
__int64* ptr2 = (__int64*)&number;

*ptr2 = 0xAABBCCDDFF;
```

``` __int64 ``` 크기의 포인터를 만든 후, 원래는 ``` int ``` 타입이었던 ``` number ```의 주소값을 넣어주었다. 그런 다음, ``` &ptr2 ```를 검색해 메모리 주소를 찾아가서 값을 확인해보자.

![Alt Text](/assets/images/posts_img/basics/cpp/pointer/pointer-basic/memory2.PNG)   

4바이트의 ``` number ``` 변수에 값이 들어가니 앞부분이 밀려서 다음 메모리에까지 저장이 된 걸 확인할 수 있다. 만약 다음 메모리에 중요한 값이 들어가 있었다면 이런 해프닝이 벌어짐으로써 데이터가 덮어씌워지게 되고 큰 문제가 발생하게 되는 것이다. 그러니 포인터를 사용할 때는 항상 신중해야한다.

***

## 👻 글을 마치며
이번 시간에는 포인터에 대해 알아보았다. 처음 접했을 때 도대체 무슨 말인지 이해 못 가는 문법 중 하나였는데 이제보니 이해가 하나 둘 간다. 복습을 확실히 하지 않으면 100퍼센트 헷갈릴 것 같다. 헷갈리지 않도록 복습 열심히 해야겠다.

***

_[소스코드 보러가기](https://github.com/choi-dan-di/study_cpp/tree/main/pointer/pointer-basic)_

***

_출처_   
_[인프런 Rookies님 강의](https://inf.run/bje8)_   