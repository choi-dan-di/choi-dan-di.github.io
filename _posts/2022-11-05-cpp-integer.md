---
title: "[C++] 변수 타입 : 정수"
excerpt: "다양한 변수 타입 중 '정수'와 오버플로우, 언더플로우에 대해 알아보기 (+디스어셈블리 보는 법)"

categories:
  - C/C++
tags:
  - [C/C++, C++, Visual Studio, variable, integer, overflow, underflow]

permalink: /cpp/integer/

toc: true
toc_sticky: true

date: 2022-11-05 01:27:16+0900
last_modified_at: 2022-11-05 01:27:19+0900
---

## 👻 들어가기에 앞서
이번 시간에는 C++ 변수 선언에 대해 알아보자. 우선 변수 설정은 다른 프로그래밍 언어와 다르지 않다. 타입과 변수 이름을 지정해주면 되는데, 우리가 이전 시간에 어셈블리어를 공부 했는데, 이제 C++을 공부하는 입장에서는 어떻게 이 둘을 연결 시킬지 감이 쉽게 잡히지 않는다. 왜 우리가 어셈블리어를 공부했는지 알아보려면 Visual Studio에서 간단한 설정만 하면 된다.   

새 프로젝트를 만들게 되면 기본적으로 ``` Hello World ```를 출력하는 코드가 세팅되어있는 파일이 하나 만들어지는데, 여기서 출력 부분에 **브레이크 포인트**를 잡고 디버그를 실행시킨 후에 **디스어셈블리**를 오픈시키면 우리가 왜 어셈블리어를 공부했는 지 알 수 있다.

> **디스어셈블리** 여는 법   
``` 디버그 👉 창 👉 디스어셈블리 ``` 혹은 단축키 ``` Ctrl+Alt+D ```를 입력하면 쉽게 창을 열 수 있다.

![Alt Text](/assets/images/posts_img/basics/cpp/variable/integer/disassembly.PNG)   

이러면 우리가 이제껏 공부해왔던 어셈블리어가 어떻게 기계어와 일대일 대응을 하는지, 그리고 프로젝트가 어떤 과정으로 진행되는 지에 대해 대략적으로 알 수 있다. 크게 중요한 건 아니지만 개념 이해는 필수!

***

### 🌱 TMI
> 프로그램 실행 : ``` Ctrl+F5 ``` 또는 ``` 디버그 👉 디버깅하지 않고 시작 ```
> 프로그램 디버그 : ``` F5 ``` 또는 ``` 디버그 👉 디버깅 시작 ```

> 💡   
1. **솔루션 탐색기** 창을 사용해 파일을 추가/관리한다.
2. **팀 탐색기** 창을 사용해 소스 제어에 연결한다.
3. **출력** 창을 사용해 빌드 출력 및 기타 메시지를 확인한다.
4. **오류 목록** 창을 사용해 오류를 본다.
5. ``` 프로젝트 👉 새 항목 추가 ```로 이동해 새 코드 파일을 만들거나, ``` 프로젝트 👉 기존 항목 추가 ```로 이동해 기존 코드 파일을 프로젝트에 추가할 수 있다.
6. 나중에 이 프로젝트를 다시 열려면 ``` 파일 👉 열기 👉 프로젝트 ```로 이동하고 ``` .sln ```파일을 선택한다.

> 주석처리는 ``` Ctrl+K+C ```로 한다.   
주석 풀기는 ``` Ctrl+K+U ```로 한다.   
(Visual Studio 단축키임)

***

## 👻 변수 선언
변수 선언은 간단하다.   

```c++
[타입] [이름];
or
[타입] [이름] = [초기값];

ex)
int hp = 100;
```

C++은 **세미콜론(;)**이 필수로 뒤에 붙는다. (안 붙이면 에러나니 항상 확인할 것)

> 💡   
C++에선 _컴파일러_ 가 알아서 변수를 **section .data**로 옮겨주기 때문에 어셈블러와 다르게 따로 공간을 지정할 필요가 없다. 0이 아닌 초기화 값이 있으면 **.data** 영역에, 초기값이 0이거나 초기값이 없는 변수라면 **.bss** 영역에 저장된다.

```c++
#include <iostream>
using namespace std;

int hp = 100;

int main()
{
    cout << "체력이 " << hp << " 남았습니다" << endl;
}
```

***

기본적으로 변수 선언 타입은 다음과 같다.   

```c++
char a;  // 1바이트 (-128~127)
short b; // 2바이트 (-32768~32767)
int c; // 4바이트 (-21.4억~21.4억)
__int64 d; // 8바이트(long long) (어마어마하게 큼)
```

기본적으로 선언하면 부호 있는(signed) 변수를 선언하게 되고, 부호가 없는 정수(양의 정수)를 선언하고 싶으면 앞부분에 ``` unsigned ```를 붙이면 된다.

```c++
unsigned char a; // 1바이트 (0~255)
unsigned short b; // 2바이트 (0~65536)
unsigned int c; // 4바이트 (0~42.9억)
unsigned __int64 d; // 8바이트(long long) (0~어마어마하게 큼)
```

> 💡 귀찮은데 그냥 대충 4바이트로 가면 안 될까?   
👉 콘솔/모바일 게임 같은 경우는 메모리가 늘 부족하다.   
👉 온라인 게임 같은 경우 ``` 4바이트 * 1만명 ...``` 기하급수적으로 늘어나서 최적화가 힘들게 된다.   
그러니 대략적으로라도 어떤 기능을 만들 때 어느 정도 범위가 예측이 된다면 그에 맞는 타입을 사용하는 게 **메모리 관리**에 좋다.   
<br>
cf) 이론적으로 양수만 존재할 수 있는 데이터라면 무조건 **unsigned**를 사용하는 게 좋아보이지만 생각보다 의견이 갈린다.   
- 레벨이 음수라는 것은 말이 안 된다. 👉 그럼 차라리 그 자리에서 프로그램을 크래시 내서 버그를 빨리 찾는 게 낫다.   
- **unsigned / signed** 사이의 변환에서 버그가 일어날 수 있다.   
<br>
고로 이건 _팀 분위기, 코딩 스타일_ 에 따라서 다르다!

***

#### 🪐 오버플로우(Overflow)와 언더플로우(Underflow)
예를 들어 아래와 같이 코드를 짰다고 생각해보자.   

```c++
short b;
b = 32767;  // 최대값
b = b + 1;

cout << b << endl;
```

결과값은 ``` 32768 ```이 나와야 할 것 같은데 막상 코드를 실행시켜보면 ``` -32768 ```이 나오게 된다.   

왜 그럴까?   
단순히 생각해보면 ``` 32768 ```이 나와야겠지만 **short**로 범위를 지정해 줬기 때문에 비트 단위로 생각해보면 단순하게 1을 더해서 **최상위 비트가 1이 되며 음수 최소값이 결과**로 나오기 때문이다.   
이 것을 **정수 오버플로우(Overflow)**라고 하며 반대로는 **언더플로우**라고 한다.   

```c++
// 언더플로우 예시

ub = 0;
ub = ub - 1;
cout << ub << endl;
```

값이 ``` -1 ```이 나올 것 같지만 해당 범위의 최대값인 ``` 65535 ```가 나오게 된다. 이를 **언더플로우(Underflow)**라고 한다.

***

## 👻 글을 마치며
이번 시간에는 C++ 초기세팅과 변수 타입 중에 하나인 정수에 대해 공부해보았다. 항상 프로그래밍 언어를 처음 접하면 하는 게 Hello World부터 출력하고 그 다음 정수 변수 선언이라 크게 다를 건 없었다. 하지만 출력 부분에서 코드가 달라 익숙치 않았던 점과 ``` .cpp ``` 파일로 실행시키면 디버그가 되지 않고 ``` .sln(솔루션 파일) ```로 프로젝트를 재시작 해야 이상없이 잘 돌아간다는 것을 알게되었다. 역시 하나를 알면 둘은 모르는 프로그래밍의 세계다. 😅

***

_[소스코드 보러가기](https://github.com/choi-dan-di/study_cpp/tree/main/variable/integer)_

***

_출처_   
_[인프런 Rookies님 강의](https://inf.run/bje8)_   